// secp256k1_point.cl - Elliptic curve point operations in Jacobian coordinates
//
// secp256k1 curve: y² = x³ + 7 over GF(p)
// Jacobian: (X, Y, Z) represents affine (X/Z², Y/Z³)
// Point at infinity has Z = 0.
//
// Requires: secp256k1_fe.cl and secp256k1_scalar.cl to be concatenated before this.

// Generator point G (affine x-coordinate, big-endian bytes)
__constant uchar GX_BYTES[32] = {
    (uchar)0x79, (uchar)0xBE, (uchar)0x66, (uchar)0x7E, (uchar)0xF9, (uchar)0xDC, (uchar)0xBB, (uchar)0xAC,
    (uchar)0x55, (uchar)0xA0, (uchar)0x62, (uchar)0x95, (uchar)0xCE, (uchar)0x87, (uchar)0x0B, (uchar)0x07,
    (uchar)0x02, (uchar)0x9B, (uchar)0xFC, (uchar)0xDB, (uchar)0x2D, (uchar)0xCE, (uchar)0x28, (uchar)0xD9,
    (uchar)0x59, (uchar)0xF2, (uchar)0x81, (uchar)0x5B, (uchar)0x16, (uchar)0xF8, (uchar)0x17, (uchar)0x98
};

// Generator point G (affine y-coordinate, big-endian bytes)
__constant uchar GY_BYTES[32] = {
    (uchar)0x48, (uchar)0x3A, (uchar)0xDA, (uchar)0x77, (uchar)0x26, (uchar)0xA3, (uchar)0xC4, (uchar)0x65,
    (uchar)0x5D, (uchar)0xA4, (uchar)0xFB, (uchar)0xFC, (uchar)0x0E, (uchar)0x11, (uchar)0x08, (uchar)0xA8,
    (uchar)0xFD, (uchar)0x17, (uchar)0xB4, (uchar)0x48, (uchar)0xA6, (uchar)0x85, (uchar)0x54, (uchar)0x19,
    (uchar)0x9C, (uchar)0x47, (uchar)0xD0, (uchar)0x8F, (uchar)0xFB, (uchar)0x10, (uchar)0xD4, (uchar)0xB8
};

// Precomputed table: G_TABLE[i] = i * G for i = 0..15 (Jacobian coords)
// Each point = 24 uints (8 for X, 8 for Y, 8 for Z)
// Layout: [X[0..7], Y[0..7], Z[0..7]] with limb 0 = LSB
// Generated by: cargo run --bin gen_g_table
__constant uint G_TABLE[16][24] = {
    { // 0*G (infinity)
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u,
        0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 1*G
        0x16F81798u, 0x59F2815Bu, 0x2DCE28D9u, 0x029BFCDBu, 0xCE870B07u, 0x55A06295u, 0xF9DCBBACu, 0x79BE667Eu,
        0xFB10D4B8u, 0x9C47D08Fu, 0xA6855419u, 0xFD17B448u, 0x0E1108A8u, 0x5DA4FBFCu, 0x26A3C465u, 0x483ADA77u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 2*G
        0x5C709EE5u, 0xABAC09B9u, 0x8CEF3CA7u, 0x5C778E4Bu, 0x95C07CD8u, 0x3045406Eu, 0x41ED7D6Du, 0xC6047F94u,
        0x50CFE52Au, 0x236431A9u, 0x3266D0E1u, 0xF7F63265u, 0x466CEAEEu, 0xA3C58419u, 0xA63DC339u, 0x1AE168FEu,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 3*G
        0xBCE036F9u, 0x8601F113u, 0x836F99B0u, 0xB531C845u, 0xF89D5229u, 0x49344F85u, 0x9258C310u, 0xF9308A01u,
        0x84B8E672u, 0x6CB9FD75u, 0x34C2231Bu, 0x6500A999u, 0x2A37F356u, 0x0FE337E6u, 0x632DE814u, 0x388F7B0Fu,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 4*G
        0xE8C4CD13u, 0x74FA94ABu, 0x0EE07584u, 0xCC6C1390u, 0x930B1404u, 0x581E4904u, 0xC10D80F3u, 0xE493DBF1u,
        0x47739922u, 0xCFE97BDCu, 0xBFBDFE40u, 0xD967AE33u, 0x8EA51448u, 0x5642E209u, 0xA0D455B7u, 0x51ED993Eu,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 5*G
        0xB240EFE4u, 0xCBA8D569u, 0xDC619AB7u, 0xE88B84BDu, 0x0A5C5128u, 0x55B4A725u, 0x1A072093u, 0x2F8BDE4Du,
        0xA6AC62D6u, 0xDCA87D3Au, 0xAB0D6840u, 0xF788271Bu, 0xA6C9C426u, 0xD4DBA9DDu, 0x36E5E3D6u, 0xD8AC2226u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 6*G
        0x60297556u, 0x2F057A14u, 0x8568A18Bu, 0x82F6472Fu, 0x355235D3u, 0x20453A14u, 0x755EEEA4u, 0xFFF97BD5u,
        0xB075F297u, 0x3C870C36u, 0x518FE4A0u, 0xDE80F0F6u, 0x7F45C560u, 0xF3BE9601u, 0xACFBB620u, 0xAE12777Au,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 7*G
        0xCAC4F9BCu, 0xE92BDDEDu, 0x0330E39Cu, 0x3D419B7Eu, 0xF2EA7A0Eu, 0xA398F365u, 0x6E5DB4EAu, 0x5CBDF064u,
        0x087264DAu, 0xA5082628u, 0x13FDE7B5u, 0xA813D0B8u, 0x861A54DBu, 0xA3178D6Du, 0xBA255960u, 0x6AEBCA40u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 8*G
        0xE10A2A01u, 0x67784EF3u, 0xE5AF888Au, 0x0A1BDD05u, 0xB70F3C2Fu, 0xAFF3843Fu, 0x5CCA351Du, 0x2F01E5E1u,
        0x6CBDE904u, 0xB5DA2CB7u, 0xBA5B7617u, 0xC2E213D6u, 0x132D13B4u, 0x293D082Au, 0x41539949u, 0x5C4DA8A7u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 9*G
        0xFC27CCBEu, 0xC35F110Du, 0x4C57E714u, 0xE0979697u, 0x9F559ABDu, 0x09AD178Au, 0xF0C7F653u, 0xACD484E2u,
        0xC64F9C37u, 0x05CC262Au, 0x375F8E0Fu, 0xADD888A4u, 0x763B61E9u, 0x64380971u, 0xB0A7D9FDu, 0xCC338921u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 10*G
        0x47E247C7u, 0x52A68E2Au, 0x1943C2B7u, 0x3442D49Bu, 0x1AE6AE5Du, 0x35477C7Bu, 0x47F3C862u, 0xA0434D9Eu,
        0x037368D7u, 0x3CBEE53Bu, 0xD877A159u, 0x6F794C2Eu, 0x93A24C69u, 0xA3B6C7E6u, 0x5419BC27u, 0x893ABA42u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 11*G
        0x5DA008CBu, 0xBBEC1789u, 0xE5C17891u, 0x5649980Bu, 0x70C65AACu, 0x5EF4246Bu, 0x58A9411Eu, 0x774AE7F8u,
        0xC953C61Bu, 0x301D74C9u, 0xDFF9D6A8u, 0x372DB1E2u, 0xD7B7B365u, 0x0243DD56u, 0xEB6B5E19u, 0xD984A032u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 12*G
        0x70AFE85Au, 0xC5B0F470u, 0x9620095Bu, 0x687CF441u, 0x4D734633u, 0x15C38F00u, 0x48E7561Bu, 0xD01115D5u,
        0xF4062327u, 0x6B051B13u, 0xD9A86D52u, 0x79238C5Du, 0xE17BD815u, 0xA8B64537u, 0xC815E0D7u, 0xA9F34FFDu,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 13*G
        0x19405AA8u, 0xDEEDDF8Fu, 0x610E58CDu, 0xB075FBC6u, 0xC3748651u, 0xC7D1D205u, 0xD975288Bu, 0xF28773C2u,
        0xDB03ED81u, 0x29B5CB52u, 0x521FA91Fu, 0x3A1A06DAu, 0x65CDAF47u, 0x758212EBu, 0x8D880A89u, 0x0AB0902Eu,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 14*G
        0x60E823E4u, 0xE49B241Au, 0x678949E6u, 0x26AA7B63u, 0x07D38E32u, 0xFD64E67Fu, 0x895E719Cu, 0x499FDF9Eu,
        0x03A13F5Bu, 0xC65F40D4u, 0x7A3F95BCu, 0x464279C2u, 0xA7B3D464u, 0x90F044E4u, 0xB54E8551u, 0xCAC2F6C4u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    },
    { // 15*G
        0xE27E080Eu, 0x44ADBCF8u, 0x3C85F79Eu, 0x31E5946Fu, 0x095FF411u, 0x5A465AE3u, 0x7D43EA96u, 0xD7924D4Fu,
        0xF6A26B58u, 0xC504DC9Fu, 0xD896D3A5u, 0xEA40AF2Bu, 0x28CC6DEFu, 0x83842EC2u, 0xA86C72A6u, 0x581E2872u,
        0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u
    }
};

// Point structure: 3 field elements (X, Y, Z) in Jacobian coordinates
// We pass points as arrays of 24 uints (3 * 8 limbs)
// Layout: [X[0..7], Y[0..7], Z[0..7]]

// Set point to infinity (Z = 0)
inline void pt_infinity(__private uint* p) {
    // X = 1, Y = 1, Z = 0
    fe_one(p);           // X
    fe_one(p + 8);       // Y
    fe_zero(p + 16);     // Z
}

// Check if point is at infinity
inline int pt_is_infinity(__private const uint* p) {
    return fe_is_zero(p + 16);  // Z == 0
}

// Copy point
inline void pt_copy(__private uint* r, __private const uint* p) {
    for (int i = 0; i < 24; i++) r[i] = p[i];
}

// Load generator point G
inline void pt_generator(__private uint* p) {
    fe_from_constant_bytes(p, GX_BYTES);       // X = Gx
    fe_from_constant_bytes(p + 8, GY_BYTES);   // Y = Gy
    fe_one(p + 16);                            // Z = 1 (affine point)
}

// Point doubling: r = 2*p
// Uses standard Jacobian doubling formulas for a=0 curves.
inline void pt_double(__private uint* r, __private const uint* p) {
    if (pt_is_infinity(p) || fe_is_zero(p + 8)) {
        pt_infinity(r);
        return;
    }

    __private const uint* px = p;
    __private const uint* py = p + 8;
    __private const uint* pz = p + 16;

    uint y2[8], s[8], m[8], x2[8];
    uint t1[8], t2[8];

    // Y²
    fe_sqr(y2, py);

    // S = 4*X*Y²
    fe_mul(s, px, y2);
    fe_add(s, s, s);  // 2*X*Y²
    fe_add(s, s, s);  // 4*X*Y²

    // M = 3*X² (since a=0 for secp256k1)
    fe_sqr(x2, px);
    fe_add(m, x2, x2);  // 2*X²
    fe_add(m, m, x2);   // 3*X²

    // X3 = M² - 2*S
    fe_sqr(t1, m);          // M²
    fe_sub(t1, t1, s);      // M² - S
    fe_sub(r, t1, s);       // M² - 2*S = X3

    // Y3 = M*(S - X3) - 8*Y⁴
    fe_sqr(t1, y2);         // Y⁴
    fe_add(t1, t1, t1);     // 2*Y⁴
    fe_add(t1, t1, t1);     // 4*Y⁴
    fe_add(t1, t1, t1);     // 8*Y⁴

    fe_sub(t2, s, r);       // S - X3
    fe_mul(t2, m, t2);      // M*(S - X3)
    fe_sub(r + 8, t2, t1);  // M*(S - X3) - 8*Y⁴ = Y3

    // Z3 = 2*Y*Z
    fe_mul(t1, py, pz);
    fe_add(r + 16, t1, t1); // 2*Y*Z = Z3
}

// Point addition: r = p1 + p2
// Uses standard Jacobian addition formulas.
inline void pt_add(__private uint* r, __private const uint* p1, __private const uint* p2) {
    if (pt_is_infinity(p1)) {
        pt_copy(r, p2);
        return;
    }
    if (pt_is_infinity(p2)) {
        pt_copy(r, p1);
        return;
    }

    __private const uint* x1 = p1;
    __private const uint* y1 = p1 + 8;
    __private const uint* z1 = p1 + 16;
    __private const uint* x2 = p2;
    __private const uint* y2 = p2 + 8;
    __private const uint* z2 = p2 + 16;

    uint z1_2[8], z2_2[8], z1_3[8], z2_3[8];
    uint u1[8], u2[8], s1[8], s2[8];
    uint h[8], rr[8], h2[8], h3[8];
    uint u1_h2[8], t1[8];

    // Z1², Z2²
    fe_sqr(z1_2, z1);
    fe_sqr(z2_2, z2);

    // Z1³, Z2³
    fe_mul(z1_3, z1_2, z1);
    fe_mul(z2_3, z2_2, z2);

    // U1 = X1*Z2², U2 = X2*Z1²
    fe_mul(u1, x1, z2_2);
    fe_mul(u2, x2, z1_2);

    // S1 = Y1*Z2³, S2 = Y2*Z1³
    fe_mul(s1, y1, z2_3);
    fe_mul(s2, y2, z1_3);

    // H = U2 - U1
    fe_sub(h, u2, u1);

    // R = S2 - S1
    fe_sub(rr, s2, s1);

    // If H = 0:
    if (fe_is_zero(h)) {
        if (fe_is_zero(rr)) {
            // Points are equal, do doubling
            pt_double(r, p1);
            return;
        } else {
            // Points are inverses, return infinity
            pt_infinity(r);
            return;
        }
    }

    // H², H³
    fe_sqr(h2, h);
    fe_mul(h3, h2, h);

    // U1*H²
    fe_mul(u1_h2, u1, h2);

    // X3 = R² - H³ - 2*U1*H²
    fe_sqr(t1, rr);          // R²
    fe_sub(t1, t1, h3);      // R² - H³
    fe_sub(t1, t1, u1_h2);   // R² - H³ - U1*H²
    fe_sub(r, t1, u1_h2);    // R² - H³ - 2*U1*H² = X3

    // Y3 = R*(U1*H² - X3) - S1*H³
    fe_sub(t1, u1_h2, r);    // U1*H² - X3
    fe_mul(t1, rr, t1);      // R*(U1*H² - X3)
    fe_mul(h3, s1, h3);      // S1*H³ (reuse h3)
    fe_sub(r + 8, t1, h3);   // Y3

    // Z3 = H*Z1*Z2
    fe_mul(t1, h, z1);
    fe_mul(r + 16, t1, z2);  // Z3
}

// Scalar multiplication: r = k * p
// Uses double-and-add algorithm, processing from LSB to MSB.
inline void pt_mul(__private uint* r, __private const uint* k, __private const uint* p) {
    if (sc_is_zero(k) || pt_is_infinity(p)) {
        pt_infinity(r);
        return;
    }

    uchar k_bytes[32];
    sc_to_bytes(k_bytes, k);

    uint result[24], base[24];
    uint tmp_add[24], tmp_dbl[24];  // Hoist outside loop to reduce register pressure
    pt_infinity(result);
    pt_copy(base, p);

    // Process from LSB to MSB
    for (int byte_idx = 31; byte_idx >= 0; byte_idx--) {
        uchar b = k_bytes[byte_idx];
        for (int bit = 0; bit < 8; bit++) {
            if (((b >> bit) & 1u) == 1u) {
                pt_add(tmp_add, result, base);
                pt_copy(result, tmp_add);
            }
            pt_double(tmp_dbl, base);
            pt_copy(base, tmp_dbl);
        }
    }

    pt_copy(r, result);
}

// Multiply generator G by scalar k: r = k * G
// Uses 4-bit windowed multiplication with precomputed G_TABLE
// MSB-first fixed-window: no warp divergence, ping-pong buffers
// pt_double(∞)=∞ and pt_add(∞,P)=P, so uniform loop body is safe
inline void pt_mul_generator(__private uint* r, __private const uint* k) {
    uchar k_bytes[32];
    sc_to_bytes(k_bytes, k);

    uint buf0[24], buf1[24], selected[24];
    __private uint* acc = buf0;
    __private uint* tmp = buf1;
    pt_infinity(acc);

    // Process 32 bytes MSB-first, high nibble then low nibble per byte
    for (int byte_idx = 0; byte_idx < 32; byte_idx++) {
        uchar b = k_bytes[byte_idx];

        // High nibble (bits 4-7)
        for (int i = 0; i < 4; i++) {
            pt_double(tmp, acc);
            __private uint* swap = acc; acc = tmp; tmp = swap;
        }
        uint nibble = (b >> 4) & 0xFu;
        for (int j = 0; j < 24; j++) selected[j] = G_TABLE[nibble][j];
        pt_add(tmp, acc, selected);
        { __private uint* swap = acc; acc = tmp; tmp = swap; }

        // Low nibble (bits 0-3)
        for (int i = 0; i < 4; i++) {
            pt_double(tmp, acc);
            __private uint* swap = acc; acc = tmp; tmp = swap;
        }
        nibble = b & 0xFu;
        for (int j = 0; j < 24; j++) selected[j] = G_TABLE[nibble][j];
        pt_add(tmp, acc, selected);
        { __private uint* swap = acc; acc = tmp; tmp = swap; }
    }

    // Copy final result (only copy needed)
    pt_copy(r, acc);
}

// Convert to affine coordinates
// Returns 0 on success, 1 if point is at infinity
inline int pt_to_affine(__private uint* x_out, __private uint* y_out, __private const uint* p) {
    if (pt_is_infinity(p)) {
        return 1;
    }

    __private const uint* px = p;
    __private const uint* py = p + 8;
    __private const uint* pz = p + 16;

    uint z_inv[8], z_inv2[8], z_inv3[8];
    fe_inv(z_inv, pz);
    fe_sqr(z_inv2, z_inv);
    fe_mul(z_inv3, z_inv2, z_inv);

    fe_mul(x_out, px, z_inv2);
    fe_mul(y_out, py, z_inv3);

    return 0;
}

// Get compressed public key (33 bytes) from point
// Format: 0x02 if y is even, 0x03 if y is odd, followed by 32-byte x
// Returns 0 on success, 1 if point is at infinity
inline int pt_to_compressed_pubkey(__private uchar* pubkey, __private const uint* p) {
    uint x[8], y[8];
    if (pt_to_affine(x, y, p) != 0) {
        return 1;
    }

    // Check if y is odd (look at least significant bit of least significant limb)
    pubkey[0] = (y[0] & 1u) ? (uchar)0x03 : (uchar)0x02;

    // Write x in big-endian
    fe_to_bytes(pubkey + 1, x);

    return 0;
}
