//! Generate G_TABLE for windowed scalar multiplication
//!
//! Run with: cargo run --bin gen_g_table

use erg_vanity_crypto::secp256k1::point::Point;
use erg_vanity_crypto::secp256k1::scalar::Scalar;

/// Convert big-endian bytes to 8×32-bit limbs (little-endian order, matching kernel)
fn bytes_to_limbs(bytes: &[u8; 32]) -> [u32; 8] {
    // Kernel's fe_from_constant_bytes does:
    //   for i in 0..8: off = (7-i)*4; r[i] = bytes[off..off+4] as big-endian u32
    // So: r[0] = bytes[28..31], r[7] = bytes[0..3]
    let mut limbs = [0u32; 8];
    for (i, limb) in limbs.iter_mut().enumerate() {
        let off = (7 - i) * 4;
        *limb = ((bytes[off] as u32) << 24)
            | ((bytes[off + 1] as u32) << 16)
            | ((bytes[off + 2] as u32) << 8)
            | (bytes[off + 3] as u32);
    }
    limbs
}

fn main() {
    // Expected kernel constants for verification
    const EXPECTED_GX: [u32; 8] = [
        0x16F81798, 0x59F2815B, 0x2DCE28D9, 0x029BFCDB, 0xCE870B07, 0x55A06295, 0xF9DCBBAC,
        0x79BE667E,
    ];
    const EXPECTED_GY: [u32; 8] = [
        0xFB10D4B8, 0x9C47D08F, 0xA6855419, 0xFD17B448, 0x0E1108A8, 0x5DA4FBFC, 0x26A3C465,
        0x483ADA77,
    ];

    println!("// Precomputed table: G_TABLE[i] = i * G for i = 0..15 (Jacobian coords)");
    println!("// Each point = 24 uints (8 for X, 8 for Y, 8 for Z)");
    println!("// Layout: [X[0..7], Y[0..7], Z[0..7]] with limb 0 = LSB");
    println!("// Generated by: cargo run --bin gen_g_table");
    println!("//");
    println!("// Kernel constants for cross-check:");
    println!("//   fe_one  = [0x00000001, 0, 0, 0, 0, 0, 0, 0]");
    println!("//   fe_zero = [0, 0, 0, 0, 0, 0, 0, 0]");
    println!(
        "//   GX limbs: [{:#010X}, {:#010X}, ...]",
        EXPECTED_GX[0], EXPECTED_GX[1]
    );
    println!(
        "//   GY limbs: [{:#010X}, {:#010X}, ...]",
        EXPECTED_GY[0], EXPECTED_GY[1]
    );
    println!("__constant uint G_TABLE[16][24] = {{");

    for i in 0..16u64 {
        let (x_limbs, y_limbs, z_limbs, x_bytes_opt, y_bytes_opt) = if i == 0 {
            // Infinity: X=1, Y=1, Z=0 (matches kernel's pt_infinity)
            let one = [1u32, 0, 0, 0, 0, 0, 0, 0];
            let zero = [0u32; 8];
            (one, one, zero, None, None)
        } else {
            // Compute i * G
            let scalar_bytes = {
                let mut bytes = [0u8; 32];
                bytes[31] = i as u8;
                bytes
            };
            let scalar = Scalar::from_bytes(&scalar_bytes).unwrap();
            let point = Point::mul_generator(&scalar);
            let (x, y) = point.to_affine().expect("Point should not be infinity");

            let x_bytes = x.to_bytes();
            let y_bytes = y.to_bytes();
            let x_limbs = bytes_to_limbs(&x_bytes);
            let y_limbs = bytes_to_limbs(&y_bytes);
            let z_one = [1u32, 0, 0, 0, 0, 0, 0, 0]; // Z=1 for affine

            // Verify 1*G matches kernel constants
            if i == 1 {
                assert_eq!(x_limbs, EXPECTED_GX, "1*G X mismatch with kernel GX!");
                assert_eq!(y_limbs, EXPECTED_GY, "1*G Y mismatch with kernel GY!");
                eprintln!("✓ 1*G matches kernel GX/GY constants");
            }

            (x_limbs, y_limbs, z_one, Some(x_bytes), Some(y_bytes))
        };

        // Print entry header with big-endian bytes for verification
        print!("    {{ // {}*G", i);
        if let (Some(xb), Some(yb)) = (&x_bytes_opt, &y_bytes_opt) {
            print!(
                "\n      // X: {:02X}{:02X}{:02X}{:02X}...{:02X}{:02X}{:02X}{:02X}",
                xb[0], xb[1], xb[2], xb[3], xb[28], xb[29], xb[30], xb[31]
            );
            print!(
                "\n      // Y: {:02X}{:02X}{:02X}{:02X}...{:02X}{:02X}{:02X}{:02X}",
                yb[0], yb[1], yb[2], yb[3], yb[28], yb[29], yb[30], yb[31]
            );
        }
        println!();
        print!("        ");

        // X limbs
        for (j, limb) in x_limbs.iter().enumerate() {
            print!("{:#010X}u", limb);
            if j < 7 {
                print!(", ");
            } else {
                print!(",\n        ");
            }
        }

        // Y limbs
        for (j, limb) in y_limbs.iter().enumerate() {
            print!("{:#010X}u", limb);
            if j < 7 {
                print!(", ");
            } else {
                print!(",\n        ");
            }
        }

        // Z limbs
        for (j, limb) in z_limbs.iter().enumerate() {
            print!("{:#010X}u", limb);
            if j < 7 {
                print!(", ");
            }
        }
        println!();

        if i < 15 {
            println!("    }},");
        } else {
            println!("    }}");
        }
    }

    println!("}};");
}
